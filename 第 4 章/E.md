3.存储器的层次结构主要体现在什么地方？为什么分这些层次？计算机如何管理这些层次？<br/>
&emsp;主要体现在“缓存-主存”和“主存-辅存”这两个存储层次上。<br/>
&emsp;&emsp;① “缓存-主存”层次主要解决 CPU 和主存速度不匹配问题。从整体运行效果分析，该层次速度接近缓存，而容量和价位接近主存。缓存主存间的数据调动由硬件自动完成。<br/>
&emsp;&emsp;② “主存-辅存”层次主要解决容量问题，从整体分析，其速度更接近与主存，容量更接近辅存。主存辅存间的数据调动由硬件和操作系统共同完成。<br/>
<br/><br/>

4.说明存取周期和存取时间的区别。<br/>
&emsp;① 存取时间：又称存储器的访问时间，指启动一次存储器操作（读或写）到完成该操作所需的全部时间。分读出时间和写入时间。<br/>
&emsp;&emsp;1）读出时间：从存储器接收到有效地址开始，到产生有效输出所需的全部时间。<br/>
&emsp;&emsp;2）写入时间：从存储器接收到有效地址开始，到数据写入被选中单元为止所需的全部时间。<br/>
&emsp;② 存取周期：指存储器进行连续两次独立的存储器操作（如连续两次读操作）所需的最小间隔时间，通常存取周期大于存取时间。<br/>
<br/><br/>

8.试比较静态 RAM 和动态 RAM。<br/>
&emsp;静态 RAM：以触发器原理寄存信息。<br/>
&emsp;动态 RAM：以电容存储电荷的原理寄存信息。<br/>
<br/>
&emsp;比较：<br/>
&emsp;&emsp;优点：<br/>
&emsp;&emsp;&emsp;① 动态 RAM 集成度远高于静态 RAM （基本单元电路 MOS 管数量少）。<br/>
&emsp;&emsp;&emsp;② 动态 RAM 行列地址按先后顺序输送，没有芯片引脚，封装尺寸小。<br/>
&emsp;&emsp;&emsp;③ 动态 RAM 功耗比静态  RAM 小。<br/>
&emsp;&emsp;&emsp;⑤ 动态 RAM 价格较低。<br/>
&emsp;&emsp;缺点：<br/>
&emsp;&emsp;&emsp;① 动态 RAM 速度较静态  RAM 低。 <br/>
&emsp;&emsp;&emsp;② 动态 RAM 需配置再生电路，也会消耗部分功率。<br/>
<br/><br/>

9.什么叫刷新？为什么要刷新？说明刷新的几种方法。<br/>
&emsp;刷新：在 2ms（常用的刷新周期） 内对所有存储单元恢复一次原状态的过程。该过程实质为：先将原存信息读出，再经由刷新放大器形成原信息并重新写入。<br/>
&emsp;原因：电容上的电荷只能维持 1 ~ 2ms ，因此如果不进行刷新，及时电源不断，信息也会自动消失。<br/>
&emsp;方法：<br/>
&emsp;&emsp;① 集中刷新<br/>
&emsp;&emsp;&emsp;&emsp;在规定的一个刷新周期内，对全部存储单元集中一段时间住家进行刷新，此时须停止读/写操作，称这段时间为 “死时间” 。<br/>
&emsp;&emsp;&emsp;&emsp;对于 128 * 128 的存储芯片阵列，若存取周期为 0.5μs ，刷新周期为 2ms（4000 个存取周期） ，则对 128 行进行集中刷新需 64μs（128 个存取周期） ，其余 1926μs 用以读/写或维持信息。<br/>
&emsp;&emsp;&emsp;&emsp;死时间：64μs<br/>
&emsp;&emsp;&emsp;&emsp;死时间率：128 / 4000 * 100% = 3.2%<br/>
![集中刷新](https://github.com/RSMinBamGro/CCP-Exercises/blob/master/%E7%AC%AC%204%20%E7%AB%A0/%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0.png)<br/>
&emsp;&emsp;② 分散刷新<br/>
&emsp;&emsp;&emsp;&emsp;对每行存储单元的刷新分散到每个存取周期内完成，将存取周期分成两段，前半段用来读/写或维持信息，后半段用来刷新，若读写周期为 0.5μs，则存取周期为 1μs 。以 128 * 128 的存储芯片为例，刷新按行进行，每隔 128μs 就可以将全部存储单元刷新一遍。
&emsp;&emsp;&emsp;&emsp;如此不存在死时间，但存取周期变长，整个系统速度降低。<br/>
![分散刷新](https://github.com/RSMinBamGro/CCP-Exercises/blob/master/%E7%AC%AC%204%20%E7%AB%A0/%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0.png)
&emsp;&emsp;③ 异步刷新<br/>
&emsp;&emsp;&emsp;&emsp;集中式和分散式的折中。<br/>
&emsp;&emsp;&emsp;&emsp;对于 n * n 的存储芯片阵列，在 2ms 内对 n 行各刷新一遍，即每隔 2000μs / n 刷新一行，仅在每行的存取进行到最后时进行一次时长为一存取周期的刷新。<br/>
&emsp;&emsp;&emsp;&emsp;如此，刷新一行只停止一个存取周期，而对每行来说，刷新间隔时间仍为 2ms ，而死时间缩短为 0.5μs 。<br/>
![异步刷新](https://github.com/RSMinBamGro/CCP-Exercises/blob/master/%E7%AC%AC%204%20%E7%AB%A0/%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0.png)
<br/><br/>

11.一个 8K * 8 位的动态 RAM 芯片，其内部结构排列成 256 * 256 形式，读写周期为 0.1μs 。试问采用集中刷新、分散刷新和异步刷新的刷新间隔分别为多少？<br/>
&emsp;① 集中刷新<br/>
&emsp;&emsp;&emsp;刷新间隔：2ms <br/>
&emsp;&emsp;&emsp;对 256 行集中刷新需要：256 * 0.1μ = 25.6μs <br/>
&emsp;&emsp;&emsp;其余 2ms - 25.6μs = 19974.4μs 用以读写或维持信息。<br/>
&emsp;&emsp;&emsp;死时间为：25.6μs <br/>
&emsp;② 分散刷新<br/>
&emsp;刷新间隔：0.2μs <br/>
&emsp;每隔 256 * 0.2 = 51.2μs 刷新一行。<br/>
&emsp;③ 异步刷新<br/>
&emsp;刷新间隔：2000μs / 256 = 7.8125μs，即每隔 7.8125μs 刷新一行。<br/>
<br/><br/>

14.某 8 位微型计算机地址码为 18 位，若使用 4K * 4位 的RAM芯片组成模块板结构的存储器，试问：<br/>
&emsp;&emsp;（1）该机所允许的最大主存空间是多少？<br/>
&emsp;&emsp;（2）若每个模块板为 32K * 8位  ，共需要多少模块板？<br/>
&emsp;&emsp;（3）每个模块板内共有几片 RAM 芯片？<br/>
&emsp;&emsp;（4）共有多少片 RAM ？<br/>
&emsp;&emsp;（5）CPU 如何选择各模块板？<br/>
&emsp;（1）最大主存空间为：2 ^ 18字 * 8bits = 256KB (1B = 8bits) <br/>
&emsp;（2）模块板数：256KB / (32K * 8bits) = 8 <br/>
&emsp;（3）板内芯片数：32K * 8bits / (4K * 4bits) = 16 <br/>
&emsp;（4）芯片总数：8 * 16 = 128 <br/>
&emsp;（5）CPU 通过最高的 3 位地址译码选择模块板，通过次 3 位选择板内芯片，最末 12 位选择片内地址。<br/>
![地址格式分配](https://github.com/RSMinBamGro/CCP-Exercises/blob/master/%E7%AC%AC%204%20%E7%AB%A0/E14%E5%9C%B0%E5%9D%80%E6%A0%BC%E5%BC%8F%E5%88%86%E9%85%8D.png)
<br/><br/>

15.<br/>

17.写出 1100、1101、1110、1111 对应的汉明码。<br/>
&emsp;四位二进制数的汉明码为：C1C2b4C4b3b2b1。<br/>
&emsp;Ci（i = 1, 2, 4, ... , 2 ^ (k - 1)) 应使对应小组 j ~ j + i - 1（j = i, i + 2 * i, i + 2 * 2 * i...）位中的 “1” 的个数为偶数。<br/>
&emsp;因此，<br/>
&emsp;&emsp;C1 = b4 ⊕ b3 ⊕ b1<br/>
&emsp;&emsp;C2 = b4 ⊕ b2 ⊕ b1<br/>
&emsp;&emsp;C4 = b3 ⊕ b2 ⊕ b1<br/><br/>
&emsp;① b4b3b2b1 = 1100<br/>

18.<br/>

20.<br/>

24.<br/>

25.什么是程序访问的局部性？存储系统中哪一级才用了程序访问的局部性原理？<br/>
&emsp;程序访问的局部性：指令和数据在主存内都是连续而非随机存放的，并且有些指令数据往往会被多次调用，因此CPU 从主存取指令或数据，在一定时间内，只是对主存局部地址的访问。<br/>
&emsp;“Cache-主存” 层和 “主存-辅存” 层。<br/>

28.<br/>

30.<br/>

35.<br/>

38.<br/>

39.<br/>

41.<br/>

42.<br/>

